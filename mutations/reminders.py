import strawberry
from schedule import Scheduler
import time
import threading
from datetime import datetime, timedelta

from mailing import triggerMail
from mailing_templates import EVENT_REPORT_REMINDER_SUBJECT, EVENT_REPORT_REMINDER_BODY, EVENT_BILL_REMINDER_SUBJECT, \
    EVENT_BILL_REMINDER_BODY, REMIND_SLO_APPROVAL_SUBJECT, REMIND_SLO_APPROVAL_BODY
from models import Event
from mtypes import timezone, Event_State_Status, Bills_State_Status
from db import eventsdb
from otypes import Info
from utils import getClubDetails, getEventLink, getRoleEmails


@strawberry.mutation
def remindSLO(eventid: str, info: Info) -> bool:
    """
    Sends a reminder email to the SLO to approve the event.

    Args:
        eventid (str): The ID of the event.
        info (Info): The context of the request for user info.

    Returns:
        bool: Success or Failiure

    Raises:
        Exception: If the user is not authorized or the event does not exist.
    """
    user = info.context.user

    if user is None or user.get("role") != "cc":
        raise Exception("You do not have permission to access this resource.")

    event_ref = eventsdb.find_one({"_id": eventid})
    if not event_ref:
        raise Exception("Event not found.")

    event_instance = Event.model_validate(event_ref)
    slo_emails = getRoleEmails("slo")

    if not slo_emails:
        raise Exception("No SLO emails found to send a reminder.")

    # format email using the new concise template
    mail_uid = user["uid"]
    mail_subject = REMIND_SLO_APPROVAL_SUBJECT.safe_substitute(event=event_instance.name)
    mail_body = REMIND_SLO_APPROVAL_BODY.safe_substitute(
        event_id=event_instance.code,
        club=event_instance.clubid,
        event=event_instance.name,
        start_time=event_instance.datetimeperiod[0].strftime("%d-%m-%Y %H:%M"),
        end_time=event_instance.datetimeperiod[1].strftime("%d-%m-%Y %H:%M"),
        location=", ".join(event_instance.location) if event_instance.location else "N/A",
        eventlink=getEventLink(event_instance.code),
    )

    # send email
    triggerMail(
        mail_uid,
        mail_subject,
        mail_body,
        toRecipients=slo_emails,
        cookies=None,  # Adjust based on authentication setup
    )

    return True


def check_for_bill_status():
    """
    Checks for events that have pending bills and sends reminder emails.
    This function is meant to be run on a schedule.

    Args: None
    Returns: None
    """
    # find events ended in past 4 days, that have bill status not submitted and event
    # is complete
    current_time = datetime.now(timezone)
    four_days_ago = current_time - timedelta(days=4)

    # DEBUG:
    # four_days_ago = current_time - timedelta(minutes=4)

    pending_bills = list(eventsdb.find({
        "datetimeperiod.1": {"$gte": four_days_ago.isoformat(), "$lte": current_time.isoformat()},
        "status.state": Event_State_Status.approved.value,
        "budget": {"$exists": True, "$ne": []},
        "bills_status.state": Bills_State_Status.not_submitted.value,
    }))

    for event in pending_bills:
        pass
        event_instance = Event.model_validate(event)

        try:
            # Note: This will need appropriate cookies to work in production
            clubDetails = getClubDetails(event_instance.clubid, None)

            if len(clubDetails.keys()) == 0:
                print(f"Club does not exist for event {event_instance.code}")
                continue

            mail_club = clubDetails["email"]
            clubname = clubDetails["name"]

            # Check if budget exists for the event
            budget_reminder = ""
            if event_instance.budget and len(event_instance.budget) > 0:
                total_budget = sum(item.amount for item in event_instance.budget)

            # Prepare email
            mail_subject = EVENT_BILL_REMINDER_SUBJECT.safe_substitute(
                event_id=event_instance.code,
                event=event_instance.name,
            )

            mail_body = EVENT_BILL_REMINDER_BODY.safe_substitute(
                club=clubname,
                event=event_instance.name,
                eventlink=getEventLink(event_instance.code),
                total_budget=total_budget
            )

            # Note: In production, you'll need to use a service account or find a way to get cookies
            # This is a placeholder that will need to be adapted based on your authentication setup
            triggerMail(
                "cc autogenerated",
                mail_subject,
                mail_body,
                toRecipients=[mail_club],
                ccRecipients=getRoleEmails("cc"),
                cookies=None,  # This would need appropriate cookies in production
            )

        except Exception as e:
            print(f"Error sending reminder for event {event_instance.code}: {e}")


def check_for_ended_events():
    """
    Checks for events that have ended in the last hour and sends reminder emails.
    This function is meant to be run on a schedule.

    Args: None
    Returns: None
    """
    current_time = datetime.now(timezone)
    one_day_ago = current_time - timedelta(days=1)

    # DEBUG:
    # one_day_ago = current_time - timedelta(minutes=1)

    # find events that ended today
    ended_events = list(eventsdb.find({
        "datetimeperiod.1": {"$gte": one_day_ago.isoformat(), "$lte": current_time.isoformat()},
        "status.state": Event_State_Status.approved.value,
        "event_report_submitted": {"$ne": True},
    }))

    for event in ended_events:
        event_instance = Event.model_validate(event)

        try:
            # Note: This will need appropriate cookies to work in production
            clubDetails = getClubDetails(event_instance.clubid, None)
            
            if len(clubDetails.keys()) == 0:
                print(f"Club does not exist for event {event_instance.code}")
                continue
            
            mail_club = clubDetails["email"]
            clubname = clubDetails["name"]
            
            # Prepare email
            mail_subject = EVENT_REPORT_REMINDER_SUBJECT.safe_substitute(
                event_id=event_instance.code,
                event=event_instance.name,
            )
            
            mail_body = EVENT_REPORT_REMINDER_BODY.safe_substitute(
                club=clubname,
                event=event_instance.name,
                eventlink=getEventLink(event_instance.code),
            )
            
            # Note: In production, you'll need to use a service account or find a way to get cookies
            # This is a placeholder that will need to be adapted based on your authentication setup
            triggerMail(
                "cc autogenerated",
                mail_subject,
                mail_body,
                toRecipients=[mail_club],
                ccRecipients=getRoleEmails("cc"),
                cookies=None,  # This would need appropriate cookies in production
            )
            
        except Exception as e:
            print(f"Error sending reminder for event {event_instance.code}: {e}")


def start_scheduler_instance(scheduler_instance):
    while True:
        scheduler_instance.run_pending()
        time.sleep(1)

# Start the scheduler in a background thread
def init_event_reminder_system():
    """
    Initializes the event reminder system by starting the scheduler in a background thread.

    Args: None
    Returns: None
    """
    ended_scheduler = Scheduler()
    # ended_scheduler.every(1).minutes.do(check_for_ended_events)
    ended_scheduler.every().day.at("00:00").do(check_for_ended_events)
    threading.Thread(target=start_scheduler_instance, args=(ended_scheduler,), daemon=True).start()

    bill_scheduler = Scheduler()
    # bill_scheduler.every(4).minutes.do(check_for_bill_status)
    bill_scheduler.every(4).days.at("00:00").do(check_for_bill_status)
    threading.Thread(target=start_scheduler_instance, args=(bill_scheduler,), daemon=True).start()


mutations = [
    remindSLO
]
