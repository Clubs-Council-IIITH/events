from schedule import Scheduler
import time
import threading
from datetime import datetime, timedelta

from mailing import triggerMail
from mailing_templates import EVENT_REPORT_REMINDER_SUBJECT, EVENT_REPORT_REMINDER_BODY, EVENT_BILL_REMINDER_SUBJECT, \
    EVENT_BILL_REMINDER_BODY
from models import Event
from mtypes import timezone, Event_State_Status, Bills_State_Status
from db import eventsdb
from utils import getClubDetails, getEventLink, getRoleEmails

def check_for_bill_status():
    """
    Checks for events that have pending bills and sends reminder emails.
    This function is meant to be run on a schedule.

    Args: None
    Returns: None
    """
    # find events ended in past 4 days, that have bill status not submitted and event
    # is complete
    current_time = datetime.now(timezone)
    four_days_ago = current_time - timedelta(days=7)

    pending_bills = list(eventsdb.find({
        "datetimeperiod.1": {"$gte": four_days_ago.isoformat(), "$lte": current_time.isoformat()},
        "status.state": Event_State_Status.approved.value,
        "budget": {"$exists": True, "$ne": []},
        "bills_status.state": Bills_State_Status.not_submitted.value,
    }))

    for event in pending_bills:
        pass
        event_instance = Event.model_validate(event)

        try:
            # Note: This will need appropriate cookies to work in production
            clubDetails = getClubDetails(event_instance.clubid, None)

            if len(clubDetails.keys()) == 0:
                print(f"Club does not exist for event {event_instance.code}")
                continue

            mail_club = clubDetails["email"]
            clubname = clubDetails["name"]

            # Check if budget exists for the event
            budget_reminder = ""
            if event_instance.budget and len(event_instance.budget) > 0:
                total_budget = sum(item.amount for item in event_instance.budget)

            # Prepare email
            mail_subject = EVENT_BILL_REMINDER_SUBJECT.safe_substitute(
                event_id=event_instance.code,
                event=event_instance.name,
            )

            mail_body = EVENT_BILL_REMINDER_BODY.safe_substitute(
                club=clubname,
                event=event_instance.name,
                eventlink=getEventLink(event_instance.code),
                total_budget=total_budget
            )

            # Note: In production, you'll need to use a service account or find a way to get cookies
            # This is a placeholder that will need to be adapted based on your authentication setup
            triggerMail(
                "cc autogenerated",
                mail_subject,
                mail_body,
                toRecipients=[mail_club],
                ccRecipients=getRoleEmails("cc"),
                cookies=None,  # This would need appropriate cookies in production
            )

        except Exception as e:
            print(f"Error sending reminder for event {event_instance.code}: {e}")


def check_for_ended_events():
    """
    Checks for events that have ended in the last hour and sends reminder emails.
    This function is meant to be run on a schedule.

    Args: None
    Returns: None
    """
    current_time = datetime.now(timezone)
    one_day_ago = current_time - timedelta(days=1)

    # find events that ended today
    ended_events = list(eventsdb.find({
        "datetimeperiod.1": {"$gte": one_day_ago.isoformat(), "$lte": current_time.isoformat()},
        "status.state": Event_State_Status.approved.value,
        "event_report_submitted": {"$ne": True},
    }))

    for event in ended_events:
        event_instance = Event.model_validate(event)

        try:
            # Note: This will need appropriate cookies to work in production
            clubDetails = getClubDetails(event_instance.clubid, None)
            
            if len(clubDetails.keys()) == 0:
                print(f"Club does not exist for event {event_instance.code}")
                continue
            
            mail_club = clubDetails["email"]
            clubname = clubDetails["name"]
            
            # Prepare email
            mail_subject = EVENT_REPORT_REMINDER_SUBJECT.safe_substitute(
                event_id=event_instance.code,
                event=event_instance.name,
            )
            
            mail_body = EVENT_REPORT_REMINDER_BODY.safe_substitute(
                club=clubname,
                event=event_instance.name,
                eventlink=getEventLink(event_instance.code),
            )
            
            # Note: In production, you'll need to use a service account or find a way to get cookies
            # This is a placeholder that will need to be adapted based on your authentication setup
            triggerMail(
                "cc autogenerated",
                mail_subject,
                mail_body,
                toRecipients=[mail_club],
                ccRecipients=getRoleEmails("cc"),
                cookies=None,  # This would need appropriate cookies in production
            )
            
        except Exception as e:
            print(f"Error sending reminder for event {event_instance.code}: {e}")


def start_scheduler_instance(scheduler_instance):
    while True:
        scheduler_instance.run_pending()
        time.sleep(1)

# start the scheduler in a background thread
def init_event_reminder_system():
    """
    Initializes the event reminder system by starting the scheduler in a background thread.

    Args: None
    Returns: None
    """
    ended_scheduler = Scheduler()
    ended_scheduler.every().day.at("00:00").do(check_for_ended_events)
    threading.Thread(target=start_scheduler_instance, args=(ended_scheduler,), daemon=True).start()

    bill_scheduler = Scheduler()
    bill_scheduler.every().sunday.at("12:00").do(check_for_bill_status)
    threading.Thread(target=start_scheduler_instance, args=(bill_scheduler,), daemon=True).start()
